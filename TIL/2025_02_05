부모 클래스를 담은 배열에서 특정 인덱스의 객체를 가져와 자식 클래스에만 있는 메서드를 실행하려면 형 변환 (다운캐스팅)과 is 또는 as 연산자를 사용할 수 있습니다.
  // 부모 타입 배열 생성
  Parent[] array = new Parent[2];
  array[0] = new Parent();
  array[1] = new Child(); // 업캐스팅
  // 배열에서 객체를 가져와 자식 클래스의 메서드 실행
  if (array[1] is Child child) // 패턴 매칭을 활용한 안전한 다운캐스팅
  {
       child.ChildOnlyMethod();
  }
========================================================================================================================================================================
abstract(추상) 키워드는 추상 클래스와 추상 메서드를 정의할 때 사용됩니다.
이유: 
  부모 클래스만으로 객체를 생성하지 못하게 하기 위해
  자식 클래스에서 반드시 구현해야 하는 메서드가 있을 때 사용
public abstract class Method{}
부모 클래스를 추상 클래스로 선언하더라도, 부모 클래스로 배열을 만들 수 있습니다.
단, 배열에 담긴 객체는 반드시 자식 클래스의 인스턴스여야 합니다. 
========================================================================================================================================================================
get, set 프러퍼티
get과 set이 없으면 외부에서 값을 읽거나 변경할 수 없을 때 사용해야 합니다.
{ get; set; }클래스 속성을 외부에서 읽고 수정해야 할 때
{ get; }값을 읽을 수만 있고, 수정은 불가능한 속성
{ set; }외부에서 값을 설정할 수 있지만, 읽을 수는 없게 만들 때
public int Health { get; set; }          ㅣ외부에서 읽기 & 수정 가능	              ㅣ일반적인 속성 (HP, MP 등)
public int Level { get; }                ㅣ읽기 전용 (set 없음)                    ㅣ값이 변경되면 안 될 때 (이름)
public string Password { set; }          ㅣ쓰기 전용 (get 없음)                    ㅣ보안 정보 (비밀번호, 토큰)
public int Gold { get; private set; }    ㅣ외부에서 읽기 가능, 내부에서만 수정 가능  ㅣ클래스 내부에서만 값 변경이 필요한 경우
========================================================================================================================================================================
클래스 기본값 초기화 
public class Item
{
    public bool Use { get; set; } = false;
    public bool Buy { get; set; } = false;
    public int WeaponType { get; protected set; }
    public string Name { get; protected set; }
    public string Effect { get; protected set; }
    public float AttackDamage { get; protected set; }
    public int Defense { get; protected set; }
    public string Manual { get; protected set; }
    public float Gold { get; protected set; }

    public Item(int weaponType, string name, string effect, float attackDamage, int defense, string manual, float gold)
    {
        WeaponType = weaponType;
        Name = name;
        Effect = effect;
        AttackDamage = attackDamage;
        Defense = defense;
        Manual = manual;
        Gold = gold;
    }

    public virtual void UseItem(Character player) { }
}
public class BasicArmor : Item
{
    public BasicArmor() : base(1, "수련자의 갑옷", "방어력 +5", 0, 5, "수련에 도움을 주는 갑옷입니다.", 1000) {}
}
아직 어떤 방식인지는 확실히 이해는 안가지만, 방법은 다 똑같이 하면되는것으로 보임..
public class BasicArmor : Item
{
    public BasicArmor() : base(1, "수련자의 갑옷", "방어력 +5", 0, 5, "", 1000) 
    {
        this,maunal = "this.Name";
    }
}
이런식으로 바꿀 수도 있습니다.
========================================================================================================================================================================
클래스(Class) – 참조 타입 (Reference Type)
사용 상황
   객체의 상태(데이터)가 자주 변경될 경우
   상속이 필요한 경우
   클래스의 인스턴스를 가비지 컬렉터(GC)가 관리해야 할 경우
   무거운 데이터(큰 크기의 데이터)를 다룰 때
특징
  힙(Heap)에 저장되는 참조 타입 (Reference Type)
  new 키워드로 객체를 생성하면 힙 메모리에 할당됨
  같은 객체를 여러 개의 변수가 참조할 수 있음 (즉, 얕은 복사)
  상속이 가능함
  객체가 사용되지 않으면 **GC(Garbage Collector)**가 자동으로 메모리 정리

객체의 상태를 유지해야 하거나 상속이 필요할 때 사용
힙(Heap)에 저장되므로 참조로 전달됨 (얕은 복사)
데이터가 크거나 자주 변경되는 경우 적합
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
구조체(Struct) – 값 타입 (Value Type)
사용 상황
  값이 자주 변경되지 않고 크기가 작을 때
  메모리 할당과 해제가 빈번할 때 (ex. 게임에서 위치 정보)
  GC(Garbage Collector)의 부담을 줄이고 싶을 때
  상속이 필요하지 않을 때
특징
  스택(Stack)에 저장되는 값 타입 (Value Type)
  값 타입이므로 객체를 복사하면 새로운 객체가 생성됨 (깊은 복사)
  상속이 불가능함
  기본적으로 new 없이 생성 가능
  작은 크기의 데이터를 빠르게 처리하는 데 적합

작고 간단한 데이터(위치, 크기, 색상 등)를 다룰 때 사용
값 타입으로 복사 시 깊은 복사
메모리 할당이 빠르며, GC의 영향을 덜 받음
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
인터페이스(Interface) – 행동(메서드) 정의
사용 상황
  여러 클래스가 공통된 기능을 공유해야 할 때
  클래스가 서로 다른 상속 계층에 속하지만 동일한 동작을 가져야 할 때
  다형성을 활용할 때 (특정 클래스 타입이 아닌, 공통된 인터페이스로 처리할 때)
특징
  클래스와 다르게 필드를 가질 수 없음 (단, C# 8.0 이후부터 default 메서드는 가능)
  메서드의 구현을 가지지 않고 행동(메서드)만 정의
  다중 구현이 가능 (여러 개의 인터페이스를 동시에 구현 가능)
  상속보다는 인터페이스를 통한 다형성이 더 유연한 구조를 제공

행동(메서드)만 정의하여 여러 클래스에서 공통적인 기능을 가질 수 있도록 함
다중 구현이 가능하며, 상속보다 더 유연한 설계가 가능
다형성 활용이 필요한 경우 유용
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

  특징	        ㅣ클래스(Class)	                  ㅣ구조체(Struct)	                    ㅣ인터페이스(Interface)
저장 위치	      ㅣ힙 (Heap)	                      ㅣ스택 (Stack)	                      ㅣ없음 (행동만 정의)
타입	          ㅣ참조 타입 (Reference Type)	값    ㅣ타입 (Value Type)	                ㅣ없음 (구현 클래스에서 정의)
메모리 복사	    ㅣ얕은 복사 (참조 공유)	            ㅣ깊은 복사 (새로운 객체 생성)	      ㅣN/A
상속 가능 여부  	ㅣ가능	                            ㅣ불가능	                            ㅣ불가능 (다중 구현만 가능)
생성 방식	      ㅣnew 키워드 필요	                ㅣnew 없이도 가능	                  ㅣ없음
다형성	          ㅣ가능	                            ㅣ불가능	                            ㅣ가능 (다중 구현 가능)
사용 목적	      ㅣ변경 가능성이 있는 복잡한 데이터	  ㅣ작고 가벼운 데이터 (좌표, 색상 등)	  ㅣ행동(메서드) 정의 및 다형성
